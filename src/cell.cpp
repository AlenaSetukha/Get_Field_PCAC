#include "cell.h"
#include "element_geom.h"

//===============================================================================================
//-----------------------------Default constructor-----------------------------------------------
//===============================================================================================
Cell::Cell()
{
    for (int i = 0; i < 4; i++)
    {
        cell[i][0] = 0.,cell[i][1] = 0., cell[i][2] = 0.; 
    }
    for (int i = 0; i < 3; i++)
    {
        tau[0][i] = 0., tau[1][i] = 0.;
        rkt[i] = 0.;
        norm[i] = 0.;
    }
    s = 0.;
}



//===============================================================================================
//-------------------------------Copy constructor------------------------------------------------
//===============================================================================================
Cell::Cell(const Cell& obj)
{
    for (int i = 0; i < 4; i++)
    {
        cell[i][0] = obj.cell[i][0], cell[i][1] = obj.cell[i][1], cell[i][2] = obj.cell[i][2]; 
    }
    for (int i = 0; i < 3; i++)
    {
        tau[0][i] = obj.tau[0][i], tau[1][i] =  obj.tau[1][i];
        rkt[i] = obj.rkt[i];
        norm[i] = obj.norm[i];
    }
    s = obj.s;
}




//===============================================================================================
//-------------------------------Функция заполнения----------------------------------------------
//===============================================================================================
void Cell::Cell_fill(const double (&cell_in)[4][3])
{
    // cell [4][3]
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            cell[i][j] = cell_in[i][j];
        }
    }

    // rkt
    for (int i = 0; i < 3; i++)
    {
        rkt[i] = (cell[0][i] + cell[1][i] + cell[2][i] + cell[3][i]) * 0.25;
    }

    // norm
    double a[3], b[3], c[3], d[3], ac[3], bd[3];
    for (int i = 0; i < 3; i++)
    {
        a[i] = (cell[0][i] + cell[1][i]) / 2.0;
        b[i] = (cell[1][i] + cell[2][i]) / 2.0;
        c[i] = (cell[2][i] + cell[3][i]) / 2.0;
        d[i] = (cell[3][i] + cell[0][i]) / 2.0;
        ac[i] = c[i] - a[i];
        bd[i] = d[i] - b[i];
    }
    vec_prod(ac, bd, norm);
    double len = vec_length(norm);
    for (int k = 0; k < 3; k++)
    {
        norm[k] /= len;
    }

    // s
    s = len;
    

    // tau[0] и tau[1]
    len = vec_length(ac);
    for (int k = 0; k < 3; k++) {
        tau[0][k] = ac[k] / len;
    }

    vec_prod(norm, tau[0], tau[1]);
    len = vec_length(tau[1]);
    for (int k = 0; k < 3; k++) {
        tau[1][k] /= len;
    }
}